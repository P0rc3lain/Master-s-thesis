%
%  Copyright © 2022 Mateusz Stompór. All rights reserved.
%

\chapter{Prezentacja działania}
Ostatni rozdział pracy poświęcony jest przedstawieniu wykorzystania biblioteki w prawdziwym zastosowaniu.
Decyzja pozwoli sprawdzić stabilność, użyteczność oraz przystępność interfejsu.
Będzie także okazją na dostrzeżenie potencjalnych problemów oraz nakreślenie kierunku przyszłej rozbudowy.
\section{Aplikacja demonstracyjna}
W trakcie rozwijania biblioteki tworzono wiele scen poglądowych, które w zamyśle miały weryfikować i pokazywać możliwości.
Były one jednak często ściśle skrojone pod daną funkcjonalność i nie dawały pełnego obrazu w kwestii jakości integracji pomiędzy aplikacją, a biblioteką.
Zdecydowano, że reprezentatywny przykład powinien być dziełem kompletnym pod względem funkcjonalności i realizować przypadek użycia zadany podczas projektowania silnika.
Z tego względu zdecydowano się na tworzenie aplikacji, będącej grą.
Jako cel wybrano szachy.
\fig{images/chess/gameplay.png}
    {Gra szachowa stworzona na potrzeby pracy}
    {fig:chess}
    {10cm}
\subsection{Forma}
Aplikacja stworzona została z przeznaczeniem na ekosystem Apple.
Zawiera w sobie wariant dla platform macOS, iOS, iPadOS oraz tvOS.
Każdy z nich pozwala na uruchomienie gry z widokiem planszy oraz swobodną rozgrywkę.
Największy nacisk położono jednak na wersję stacjonarną, przez wzgląd na najefektywniejsze programowanie.
Z tego względu opis obejmie jej perspektywę, choć pamiętać należy, że adaptacja rozwiązań na urządzenia mobilne nie stanowiłaby problemu, zważywszy na fakt, że silnik uruchamia się i funkcjonuje poprawnie.
\par
Renderowanie grafiki wymagało skorzystania z interfejsu okienkowego.
Dostęp do niego uzyskać można zarówno w momencie rozwoju aplikacji uruchamianej z wiersza poleceń, jak i natywnej dla systemu paczki \textit{.app}.
Silne ukierunkowanie na ekosystem sprawiło, że zdecydowano się użyć drugiej możliwości.
\par
Dystrybucja w postaci pliku \textit{.app} niesie za sobą dodatkowe konsekwencje.
Producent wymaga, aby były one podpisane za pomocą certyfikatu poświadczonego przez niego samego.
Przez wzgląd na ilość środków koniecznych do nabycia licencji nie zdecydowano się tego uczynić.
Czytelnicy pracy z tego względu mogą własnoręcznie skompilować dokument programu XCode i utworzyć paczkę w oparciu o swoje dane deweloperskie.
\par
Aplikacja jest nieskomplikowana.
Posiada pojedynczy ekran prezentujący rozgrywkę mogący występować w mnogiej liczbie w celu zapewnienia równoległej obsługi wielu sesji.
Nie istnieje możliwość dostosowania zasad, choć rozszerzenie jej o tę opcje wydaje się nie wymagać znacznego nakładu pracy.
Zdecydowano się jednak zrezygnować z tej możliwości ze wzglądu na demonstracyjne przeznaczenie.
\subsection{Materiały}
Modele figur, planszy, a także tekstury użyte w pracy stanowią własność intelektualną osób trzecich.
Upewniono się, że licencje dostarczane wraz z nimi umożliwiają nieodpłatne wykorzystanie w celach naukowych.
Zdecydowano się zrezygnować z własnoręcznego wykonania tego kroku, ponieważ modelowanie nie wpłynęłoby na cel, który starano się osiągnąć.
\subsection{Logika gry}
Aplikacja zawiera pełną implementację logiki szachowej z uwzględnieniem \textit{el passant}, roszady oraz promocji figur.
Dopuszczalne jest, żeby użytkownicy zmienili pierwotnie określony wybór figury.
Nie poddano restrykcji czasu przeznaczonego na turę zawodnika.
\fig{images/chess/choice.png}
    {Okno dialogowe pozwalające na wybór rodzaju figury podczas promocji}
    {fig:piece-choice}
    {4.8cm}
\par
Rozgrywka zakończyć może się wygraną jednego z graczy bądź remisem.
Wygrana stwierdzana jest w sytuacji gdy nastąpi szach-mat na królu zawodnika.
Pierwszą sytuacją w której zachodzi remis jest pat \longpause wszystkie możliwe ruchy doprowadziłyby do szachu.
Drugi przypadek opera się o zasadę pięćdziesięciu.
Jeśli podczas kolejnych pięćdziesięciu ruchów żaden z graczy nie zmienił pozycji giermka ani przeprowadził bicia.
Zdecydowano się nie umożliwić zawodnikom poddania się ani ogłoszenia remisu na podstawie chęci z obu stron.
\subsection{Sterowanie}
Interakcja z aplikacją oparta jest o wykorzystanie kursora i klawiatury.
Za pomocą klawiszy \textit{A} oraz \textit{D} użytkownik może dokonywać rotacji kamery, zmieniając pozycję z której obserwuje scenę.
Selekcja figury dokonywana jest za pomocą kursora myszy.
Aplikacja sygnalizuje wybór unosząc figurę nieznacznie ponad obszar planszy.
Wówczas użytkownik może wybrać docelowe pole na które chce ją poruszyć lub kliknąć poza obszar mapy, aby zrewidować podjętą decyzje.
\subsection{Ruch}
Chcąc wykorzystać możliwie dużo z możliwości biblioteki zadbano o animacje.
Tak jak zaznaczone wcześniej wybór figury jest sygnalizowany zmianą pozycji, która następuje za pomocą płynnego ruch.
Podobnie w sytuacji gdy wybór figury jest anulowany.
Przejście z jednego pola do innego wykorzystuje podobny efekt.
Figura unoszona jest ponad plansze, przenoszona do docelowego pola, a następnie opuszczana.
\subsection{Sesje gry}
Otwarte okno odpowiada pojedynczej sesji gry.
Dopuszczone jest toczenie wielu równoległych rozgrywek.
Wówczas obok siebie widoczna jest mnoga liczba obszarów roboczych.
Każda z nich jest od siebie niezależna.
Obsługa logiki, jak i proces generowania grafiki obsługiwany jest przez osobne, tworzone przy inicjacji okna instancje odpowiednich klas.
Sesje nie są persystentne.
Zamknięcie okna lub całej aplikacji wiąże się z bezpowrotnym utraceniem stanu rozgrywki.
\fig{images/chess/chess-sessions.png}
    {Interfejs pozwalający na tworzenie wielu sesji}
    {fig:chess-sessions}
    {9cm}
\section{Implementacja}
Niniejsza sekcja nakreśla pokrótce architekturę aplikacji zaprojektowaną na potrzeby wersji demonstracyjnej.
Starano się w niej zwrócić uwagę na sposób komunikacji z opracowaną biblioteką.
Ma to za zadanie posłużyć jako forma sugestii w jaki sposób dokonywać interakcji z technologią, ale także pozwolić dostrzec potencjalne niedoskonałości.
\subsection{Architektura}
Aplikacja stworzona została o oparciu o tradycyjne podejście komunikacji dla platformy - \textit{Model-View-Controller}.
Kontroler koordynuje interakcje pomiędzy użytkownikiem a logiką gry.
Przechowuje jej stan i na podstawie wyborów użytkownika dokonywanych za pośrednictwem kursora wysyła zapytania dotyczące poprawności ruchu do klasy obsługującej zasady rozgrywki.
W przypadku wykonania poprawnej akcji inicjuje zmianę pozycji figur na scenie, a następnie aktualizuje dane dotyczące obecnego stanu.
Wreszcie, posiada referencje do klas mogących modyfikować położenie kamery na scenie i dedukujących intencje gracza na podstawie zachowania kursora.
\figh{images/chess/diagram.png}
     {Uproszczony diagram prezentujący architekturę gry szachowej}
     {fig:chess-architecture}
     {11cm}
\par
Kompletny stan rozgrywki przechowywany jest w klasie \textit{GameState}.
Odnosi się do jego aktualnej wersji, przez wszystkie poprzednie aż do stanu początkowego.
Decyzja o implementacji podparta była koniecznością upewnienia się o przestrzeganiu samych zasad, ale potencjalnie posłużyć mogłoby także do obsługi cofania ruchu.
Stan, poza informacją na temat relacji pomiędzy pozycjami na planszy, a figurami określa też czy któryś z nich został wybrany przez gracza, wskazuje turę zawodnika i zadaje oczekiwania co do jego zachowania.
Ruch przebiega w trzech etapach. 
Pierwszym jest określenie, że intencją użytkownika powinno być wybranie figury.
Drugi, wskazanie na konkretną z nich, zgodną z zasadami gry.
Ostatnia, zmiana pozycji.
\lstinputlisting[language=Swift, caption=Struktura przechowująca obecny stan rozgrywki]
                {code/chess/GameState.swift}
\subsection{Aranżacja sceny}
Scena komponowana jest jednorazowo, podczas wczytywania widoku.
Wykorzystano materiały reprezentujące odpowiednio mahoń oraz sapele.
Są one wczytane pojedynczo oraz reużywane dla wszystkich modeli.
Podobne podejście zastosowano w przypadku figur.
Każdy z rodzajów występuje w pamięci dokładnie raz, ale za pomocą dodatkowych węzłów w drzewie powielany jest i odpowiednio umiejscawiany.
Figurom podczas tego procesu nadawany jest identyfikator, który określa jej kolor, rodzaj oraz id instancji w przypadku gdy powtarza się ona na planszy.
Zdecydowano się zrezygnować z mapy otoczenia, by nie odciągać uwagi użytkowników od rozgrywki.
W tym wypadku polega ona na ustaleniu jednolitej barwy i wygenerowania mapy otoczenia na jej podstawie.
Scena posiada dwa źródła światła \longpause ambientowe oraz kierunkowe.
Klasa sceny zapewnia integralność danych.
Przekazanie jej do silnika sprawi, że dostosuje on swoje wewnętrzne struktury do jej renderowania i nie zachodzi potrzeba konfigurowania dodatkowych pól manualnie.
\lstinputlisting[language=Swift, caption=Funkcja realizująca wczytywanie modeli]
                {code/chess/SceneBuilder.swift}
\subsection{Przetwarzanie wejścia}
Ze względu na specyfikę gry szachowej postęp rozgrywki bezpośrednio wynika z akcji dokonanej przez użytkownika.
W przypadku kontrolera stworzonego na potrzeby gry logikę delegacji osadzono bezpośrednio w funkcji wywoływanej po skorzystaniu z przycisku kursora.
Analizowany jest wówczas stan gry.
W przypadku jej końca, zaniechane jest dalsze procesowanie.
Gdy jednak rozgrywka nadal się toczy następuje określenie modelu, który został wybrany na podstawie współrzędnej punktu 2D wykrytego na ekranie.
W dalszym kroku następuje jego przełożenie na figurę będącą na planszy gry.
Weryfikowana jest poprawność ruchu i w momencie stwierdzenia jego dopuszczalności aktualizowany jest stan gry i uruchamiana animacja.
Analiza kończy się, a możliwość rozgrywki otrzymuje drugi gracz.
\lstinputlisting[language=Swift, caption=Logika przetwarzania interakcji]
                {code/chess/ViewController.swift}
Gra toczy się do momentu wykrycia szach-mata lub pata.
Zawodnik informowany jest za pomocą tekstu umieszczonego w rogu ekranu o zakończeniu gry.
W podobny sposób przekazywana jest informacja o wykryciu szachu.
