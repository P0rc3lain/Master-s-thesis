\section{Interfejsy programistyczne}
Ostatnim aspektem wymagającym uwagi podczas analizy bibliotek wykorzystujących akcelerację sprzętową jest interfejs dostępu do zasobów karty graficznej.
Interakcja z akceleratorem podzielona może być na dwa obszary.
Pierwszy to faktyczne wykorzystanie mocy obliczeniowej do wykonania spersonalizowanych programów \longpause shaderów lub coraz bardziej popularnych obliczeń na tensorach czy strukturach akceleracji dla ray tracingu.
W tym celu posłużyć należy się także wyspecjalizowanym językiem.
Pozostała część API odpowiedzialna jest za umożliwienie użytkownikowi dostarczenie ów programu, a także wszystkich zasobów potrzebnych do jego działania w formie buforów oraz tekstur.
Ta część oddana jest za pośrednictwem biblioteki do języka wysokiego poziomu.
\par
Współczesne API w miarę upływu czasu wydają się zbliżać do siebie coraz bardziej.
Wynika to bezpośrednio ze wspólnego trendu wraz z którym podążają dostępne rozwiązania.
Wnikliwe porównanie obrazujące skalę podobieństw odnaleźć można między innymi jako publikację na łamach blogu \textit{alain.xyz}~\cite{alain_modern_graphics_comparison}.
Wspomnianym trendem tak \longpause jak wyjaśniono we wprowadzeniu \longpause jest chęć oddania możliwie jak najniżejpoziomowo sposób w który operują jednostki graficzne.
Asynchroniczna natura wykonywania operacji na GPU i chęć minimalizacji ilości synchronizacji pomiędzy GPU i CPU sprawia, że wszystkie nowoczesne API kolejkują zadania i wysyłają je partiach.
\par
Obecnie do dyspozycji programistów Apple oddana jest możliwość skorzystania z dwóch API.
Są to OpenGL będący ogólnym standardem wspieranym przez wiele platform oraz Metal, który zaprojektowany został jako autorskie rozwiązanie Apple.
Pomimo popularności na innych platformach najświeższy otwarty standard graficzny opublikowany przez grupę Khronos \longpause Vulkan \longpause pozostaje niedostępny.
\subsection{OpenGL}
Najnowsza wersja dostępna na stacjonarnej platformie to opublikowane w 2010 roku OpenGL 4.1.
W przypadku urządzeń mobilnych jest to OpenGL ES 3.0, które pomimo zbieżności wielu zbieżności pozostaje podzbiorem stacjonarnego odpowiednika.
W 2022 roku nadal istnieje możliwość stworzenia aplikacji opartej o OpenGL, choć rozwiązanie uznane jest jako przestarzałe i niewspierane od 2018 roku.
\par
Brak wsparcia nie musi stanowić o słabości produktu jednak w przypadku OpenGL największą wadą jest przestarzałe podejście do komunikacji z GPU.
W przeciwieństwie do nowoczesnych API, które synchronizują zadania CPU oraz GPU w zminimalizowany sposób OpenGL dokonuje tego znacznie częściej.
Każdorazowe wywołanie funkcji oznacza wykonanie zapytania do GPU.
\par
Pewną niedogodność stanowi także fakt, iż OpenGL oparty był o język C.
Z tego względu wszystkie jego wywołania mają proceduralny charakter i powodują dysonans w obiektowym kodzie stworzonym w Objective-C czy Swift.
Korzystania nie ułatwia także fakt, że zasoby uzyskane z GPU bez względu na przeznaczenie i typ przekazywane są do użytkownika za pomocą zmiennej całkowitej.
Na programiście spoczywa konieczność stworzenia abstrakcji wokół pozyskanego numeru.
\par
% To jest nie do końca prawda - można pracować na wielu wątkach, ale każdy musi mieć swój kontekst.
% Zmiana kontekstu jest kosztowna czasowo
Kolejną niewątpliwą wadą rozwiązania jest sama jego architektura.
OpenGL zaprojektowane jest jako globalna maszyna stanów.
Choć nie jest to jawnie zabronione podejście sprawia, że nie istnieje efektywna możliwość komunikacja z API w sposób wielowątkowy.
W teorii dwa lub więcej wątków jest w stanie operować na API, ale współbieżne operacje są niemożliwe ponieważ wątki wpływają na siebie nawzajem za pośrednictwem zmiany stanu API.
\subsection{Metal}
Obecnie jedynym dostępnym API za pośrednictwem którego programować można GPU w ekosystemie Apple jest Metal.
Jego premiera miała miejsce w 2014 roku.
Początkowo współistniał on wraz z OpenGL 4.1, natomiast wraz z premierą macOS Mojave traktowany jest jako główne API.
\par
Funkcjonalnie nie wyróżnia się w stosunku do innych popularnych API, takich jak Vulkan czy DirectX.
Wszystkie obecnie stosują podejście kolejkowego przetwarzania zadań i minimalizują ilość udostępnianych funkcji.
Z punktu widzenia producenta obecna sytuacja jest jednak wyjątkowo korzystna.
% Wydajność wcale nie jest jakaś super,
Apple samo zarządza standardem, a fakt, że stało się także architektem układów graficznych sprawia, że są oni w stanie uzyskać optymalna wydajność.
\par
Wraz z interfejsem dla języków wysokiego poziomu biblioteka wprowadza swój język do tworzenia programów cieniujących \longpause MSL.
Jako bazę do jego stworzenia posłużył C++14, jednak z uwagi na wyspecjalizowane użycie technologii część możliwości została ograniczona.
\par
Dostęp do API realizowany jest podobnie jak w przypadku innych funkcjonalności za pomocą biblioteki.
Odbywa się to nie tylko pośrednictwem Swifta czy Objective-C.
W 2022 roku opublikowano oficjalne wsparcie dla języka \textit{C++} realizowane przy pomocy \textit{Metal-C++}.
Choć na pierwszy rzut oka wydaje się być to doskonały krok w kierunku uzyskania najlepszej możliwej wydajności, to wiążą się z tym pewne niedogodności.
\textit{Metal-C++} łączy w sobie świat automatycznego zarządzania pamięcią zaczerpniętego z natywnych języków, a także C++, który pozwala na pewną dowolność w tej kwestii.
W efekcie użytkownik decydujący się na korzystanie z API zmuszony będzie w trakcie interakcji z API jawnie przenosić obiekty pomiędzy zarządzaniem Objective-c oraz C++.
Dodatkowo, należy pamiętać, że użycie wspomnianej technologii rozszerza tylko zakres w którym C++ może zostać wykorzystany. 
Nadal należy pamiętać o konieczności interfejsowania kodu do Objective-C w celu wykorzystania go w aplikacji ekosystemu Apple.
\par
Jedynym mankamentem dotyczącym zarówno Metal, jak i OpenGL jest brak wsparcia dla systemu watchOS.
W jego przypadku skorzystać można tylko i wyłącznie ze stosunkowo wysokopoziomowyej biblioteki do rysowania \longpause Core Graphics.
Jedyną możliwością generowanie grafiki trójwymiarowej wydaje się być własnoręczne zaimplementowanie potoku renderowania opartego o CPU.
% Z tej popularności wzięły się też biblioteki do iOS, które wyglądają jak vulkan ale są wrapperem na metala
% Napisz, że metal jest super bo pozwala na doskonałe debugowanie
% Napisz, że fajne jest profilowanie kodu shaderów
