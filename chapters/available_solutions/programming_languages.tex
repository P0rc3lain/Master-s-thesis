\section{Języki programowania}
Dokonując skrupulatnej analizy należy zastanowić się również nad technologiami, które używane są w popularnych projektach.
Jako fundament wytypować można język programowania.
Obecnie szacuje się, że liczba dojrzałych wynosi około trzystu~\cite{programming_languages}.
Pomimo, że grono jest liczne to tylko kilka z nich używanych jest produkcyjnie w branży gier.
Przesłankami, które najczęściej usłyszeć można jest konieczność uzyskania optymalnej wydajności i wsparcia możliwie dużej liczby platform.
\subsection{C++}
Decyzję o stworzeniu rozszerzenia do języka C, Bjarne Stroustrup \longpause twórca C++ \longpause motywował chęcią otworzenia się na paradygmat programowania obiektowego.
Jego dzieło zachowywało wszystkie dotychczasowe korzyści wynikające z użycia niskopoziomowego języka, ale sprawiało, że programiści byli w stanie otworzyć się na projektowanie elastycznej architektury.
Pomimo upłynięcia blisko 40 lat od publikacji pierwszej wersji standardu C++ dowiódł swojej wartości i do dzisiaj jest jednym z najpopularniejszych języków programowania.
\par
Największą siłą jest mnogość platform na których jest obecny.
Począwszy od telefonów komórkowych, samochodów, kończąc na branży lotniczej i medycznej.
Zastosowania są równie zróżnicowane jak docelowe urządzenia.
Użytkownicy \longpause w postaci firm, ale także i osób prywatnych \longpause wskazują, że w głównej mierze chodzi o niezawodność.
Przez lata kompilatory uzyskały stabilność, a tysiące użytkowników aktywnie uczestniczących w procesie rozwoju pozwalają zachować pewność, nawet w sytuacjach gdzie na szali stoi życie ludzkie.
\par
Długa obecność na rynku niesie za sobą dodatkową wartość.
Pula bibliotek bogata jest w sprawdzone rozwiązania, pokrywające wiele dziedzin.
Ponadto, kompatybilność z C sprawia, że szerokie już grono bibliotek powiększane jest o te stworzone z myślą o pierwowzorze.
\par
Nie jest regułą, że C++ stanowi natywny język dla platformy.
Wręcz to rzadkie zjawisko.
Często programy C++ odpowiedzialne są za wykonywanie tylko i wyłącznie zadań intensywnych obliczeniowo lub ukierunkowanych na niską latencję.
Natomiast same wywołania i odpowiedzi dokonywane są za pośrednictwem języka operującego na wyższym poziomie abstrakcji \longpause takim jak C\#, Java czy Swift.
W razie potrzeby wspomniane interfejsowania może zachodzić także w drugą stronę \longpause z C++ do języka maszynowego.
Możliwość wkomponowania C++ w inne technologie niewątpliwie pozwoliła uniknąć wyparcia z rynku.
\par
Konceptem stojącym za stworzeniem języka C była chęć uzyskania technologii będącej w stanie zastąpić język maszynowy, zachowując przy tym możliwie jak najniższy poziom abstrakcji.
C++ podtrzymuje to podejście.
W swej istocie oba z nich posiadają proste mechanizmy.
Co za tym idzie mają bardzo niewielki narzut w stosunku do języka maszynowego.
Często, przez wzgląd na wbudowane w kompilator mechanizmy do optymalizacji kod C++ jest lepszy niż równoważny odpowiednik napisany przez człowieka bezpośrednio w formie zrozumiałej dla komputera.
\lstinputlisting[language=C++, caption=Przykład kodu w języku C++]{code/example.cpp}
\subsection{Objective-C}
Bjarne Stroustrup nie był jedynym, który dostrzegał braki w języku C i pragnął zmienić stosowane podejście.
We wczesnych latach 80 Tom Love and Brad Cox opracowali własną odpowiedź na ukłon w stronę obiektowości.
Ich dzieło \longpause Objective-C \longpause w pierwszej wersji ukazało się w 1984 roku.
Wybrane zostało przez firmę NeXT jako technologia, którą posłużą się do stworzenia ich autorskiego systemu operacyjnego NeXTSTEP.
Jest on podstawą, którą użyło Apple do rozwijania własnego systemu \longpause znanego dzisiaj pod nazwą macOS \longpause za sprawą przejęcia firmy NeXT w 1996 roku.
\par
W przeciwieństwie do C++ Objective-C nie zyskało tak licznego grona odbiorców jak C++.
Głównie za sprawą faktu, że w głównej mierze prawa do technologii spoczywały w rękach Apple.
W efekcie jest to technologia nadal szeroko-stosowana na ich własnych środowiskach, ale wybrakowana i niemalże nieobecna na innych.
Użycie i wybór Objective-C często podyktowany był koniecznością, a nie rozważną decyzją podpartą argumentami.
\par
Choć język realizuje swoją funkcje to w stosunku do C++ charakteryzuje się gorszą wydajnością.
Wynika to z faktu, że zastosowana tutaj podejście zaczerpnięte ze SmallTalka \longpause wywołanie funkcji za pośrednictwem przesyłania wiadomości do obiektu z nazwą w postaci łańcucha znakowego i listą argumentów.
W tym calu C++ wykorzystuje tablice funkcji wirtualnych, które do wywołania metody wymagają wykonania mniejszej liczby operacji lub niekiedy mogą być całkowicie pomijane.
\par
Dodatkowo, Objective-C zniechęca do siebie swoją składnią, niespotykaną w żadnym innym języku.
Wywołania metod przypominają nieco język naturalny.
W przeciwieństwie do C czy C++ każdy parametr opatrzony jest stosowną nazwą.
Programista w teorii powinien być lepiej zrozumieć działanie algorytmu jednak podejście takie ma także negatywne skutki.
Przede wszystkim wywołania metod są długie, a konieczność zamykania każdego wywołania w nawiasy kwadratowe sprawia, że niekiedy sekwencja wywołań zabiera wiele linii.
\lstinputlisting[language={[Objective]C}, caption=Przykład kodu w języku Objective-C]{code/example.m}
\subsection{Swift}
Debiut Swift nastąpił w 2014 roku.
W przeciwieństwie do wcześniej wymienionych języków Swift nie jest ukierunkowany w pojedynczy paradygmat programowania.
Wykorzystywany może być do podejścia zorientowanego obiektowo, protokołowo, a także programowania proceduralnego i funkcyjnego.
Decyzja o jego stworzeniu i inwestycja w technologie była inicjatywą Apple.
Jego kluczowe cechy były bezpośrednią odpowiedzią na zarzuty w stosunku do bolączek Objective-C.
\par
Przede wszystkim krótko bo premierze technologii \longpause w 2015 \longpause roku zdecydowano o konwersji projektu do formy open source.
Projekt przeniesiony został na platformę GitHub wraz z bibliotekami standardowymi.
Od tamtej pory producent aktywnie zachęca do zaangażowania się za pośrednictwem formularza zgłaszania błędów, propozycji rozwoju czy bezpośrednich kontrybucji.
W efekcie Swift obecny także na systemach Linux oraz Windows, a przypadek użycia zawiera nie tylko tworzenie aplikacji dla urządzeń Apple, ale język traktowany jest jako rozsądna propozycja do użycia jako technologia serwerowa.
Apple chciało zerwać z dotychczasowym wizerunkiem, który obecny był w Objective-C.
Użytkownicy dostrzegali, że platforma producenta jest jedyną w której technologia ma zastosowania.
Strategia sprawdziła się.
w 2020 roku \longpause szacowano, że Swift jest trzykrotnie częściej wykorzystywany niż swój starszy odpowiednik.
% https://www.ideamotive.co/blog/swift-vs-objective-c-which-should-you-pick-for-your-next-ios-mobile-app
\par
Sytuacją, którą traktować można jako punkt zapalny do stworzenia języka była premiera pierwszego iPhone'a w 2007 roku.
Urządzenie odniosło ogromny sukces, a każdy kolejny model pomimo stale rosnącej produkcji wciąż nie był w stanie wysycić potrzeb rynku.
Wraz z rewolucyjnym telefonem producent zaoferował światu coś jeszcze.
AppStore był sklepem dostępnym z poziomu urządzenia za pośrednictwem, którego użytkownicy mogli dodawać kolejne aplikacje.
Twórcą mógł byc nie tylko sam producent, ale w zasadzie każdy.
Pojawiał się jednak problem.
Potencjalny deweloper musiał nie tylko zaopatrzyć się w telefon, ale także odpowiedni komputer, a dodatkowo nauczyć języka niespotykanego w żadnym innym środowisku.
Apple dostrzegło, że ich trudności odstrasza programistów i w efekcie projekt pomimo doskonałej rentowności nie jest w stanie dojść do swojego szczytu możliwości, w efekcie czego wiele potencjału jest niewykorzystane.
\par
Jedna z kluczowych zalet języka jest prędkość.
Statystyki, poświadczone przez twórców wskazują na 2.6x wzrost wydajności w stosunku do pierwotnego rozwiązania.
Swift nie jest tak dobry jak C czy C++, nie mniej jednak jego narzut jest niewielki.
% https://www.cometchat.com/blog/ios-swift-objective-c-comparisonl
\par
Nie można przeoczyć także faktu, że nowy język jest czytelny.
W tym znaczeniu można jednak rozpatrywać łatwość w rozumieniu jako ekspresyjność języka.
Aplikacje napisane w Swift są bardziej zwięzłe, obniżając przy tym wymaganą od czytelnika złożoność poznawczą.
\par
Forma licencji i ekspresyjność języka to nie jedyne czynniki, które za pomocą poprawy miały wpłynąć na przystępność.
W przeciwieństwie do C czy C++ Objective-C nie posiadał jawnie publikowanych standardów, pomimo faktu iż był rozwijany i podlegał wersjonowaniu.
O nowych funkcjach użytkownicy dowiadywali się wraz z dystrybucją nowszych wersji kompilatora.
Nie pomagał fakt, że dokumentacja na stronie Apple opisująca języka opóźniona była o wiele miesięcy, dostępna tylko w jednym języku i napisana bardzo technicznie, bez przykładów.
Swift naprawia ten błąd.
Wraz z premierą twórcy opublikowali książkę w formie elektronicznej \textit{The Swift Programming Language}.
Zakładała ona, że programista nie posiada doświadczenia i stopniowo wdrażała go w coraz bardziej złożone detale języka.
Na pochwałę zasługuje również fakt, że dostępne są liczne translacje, a sam e-book jest darmowy.
Stwarza to wyraźny kontrast w stosunku to słabo opisanego Objective-C z małą ilością źródeł, dostępnych w głównej mierze tylko i wyłącznie po angielsku.
\par
Wydaje się jednak, że Objective-C nigdy nie opuści ekosystemu Apple.
Producent nabiera wody w usta ilekroć temat jest poruszany, ale widoczne są przesłanki na podstawie których sądzić można, że wspomniana teza okaże się prawdziwa.
Tak jak wyjaśniono w stosunku do języka C++ nadal istnieją scenariusze w których odczuć można wyraźna korzyść z oparcia technologii o niskopoziomowe programowanie.
Jeśli taka potrzeba zajdzie w ramach ekosystemu Apple użycie Objective-C jest jedyną drogą dzięki której połączyć można C++ oraz Swift.
\lstinputlisting[language=Swift, caption=Przykład kodu w języku Swift]{code/example.swift}
\begin{figure}
    \begin{center}
        \includegraphics[width=15cm]{images/language-interoperability.png}
    \end{center}
    \caption{Schemat łączenia wielu języków na przykładzie platformy iOS}
    \label{fig:language-interoperability}
\end{figure}
