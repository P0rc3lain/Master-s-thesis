%
%  Copyright © 2022 Mateusz Stompór. All rights reserved.
%

\subsection{Konwencje}
Decyzja o wybraniu formy dystrybucji w postaci biblioteki wpłynęła na postawione cele.
Jednym z nich było uzyskanie przystępności i możliwie niewielkiego wysiłku potrzebnego do zrozumienia kodu przez osoby trzecie.
Pomimo charakteru badawczego pracy brano pod uwagę możliwość chęci kontrybucji ze strony społeczności.
Istnieją narzędzia analizujące źródła statycznie i wskazujące błędy przez które zadanie potencjalnie będzie utrudnione.
Od pewnego progu jednak czytelność postrzegana jest subiektywnie.
Z tego względu zdecydowano się wprowadzić standard w odniesieniu do tworzonych plików i możliwie starano się zachować go dla całego kodu źródłowego.
Sprawi to, że przeglądanie zawartości repozytorium źródeł wytworzy u czytelnika intuicję i ułatwi dalszą nawigację.
\subsubsection{Zawartość plików}
Pliki w projekcie podzielone są w taki sposób, aby treść w nich osadzona odnosiła się do pojedynczego komponentu.
Negatywnie wpływa to na ich liczbę \longpause wynosi ona około 350.
Pozwala jednak zwiększyć ziarnistość podczas organizacji w katalogi, dzięki czemu precyzyjniej są one zgrupowane.
\par
Pliki Swift agregują pojedyncze klasy, struktury czy protokoły.
Wiele definicji występuje jedynie w przypadku rozszerzeń oraz alternatywnych nazw \eng{alias}.
Kategoryzowane one są w zależności od komponentu do którego się odnoszą.
% TODO: Potencjalnie tu mogę podać przykład
\par
Programy cieniujące dla pojedynczej jednostki translacyjnej posiadają definicję całego potoku, ale rozdzielono je dla różnych z nich.
Oznacza to, że dla pliku wspólnie zdefiniowane są shadery wierzchołków i fragmentów, a w przypadku programów obliczeniowych definicja występuje pojedynczo.
\par
Dla współdzielonego kodu w języku C przyjęto hybrydową strategię.
Struktury dostępne dla Swift i MSL zdefiniowane są w pojedynczych plikach.
Natomiast stałe odnoszące się do indeksów buforów pogrupowane są wspólnie w zależności od przeznaczenia.
Między sobą występują indeksy dla różnych shaderów fragmentów, ale shadery wierzchołków posiadają definicję gdzie indziej.
\subsubsection{Styl programistyczny}
Zadbano o uspójnienie stylu przyjętego w źródłach.
Określono standard w odniesieniu do formatowania.
Dokonywano jego weryfikacji za pomocą Swiftlint w przypadku kodu języka Swift.
Clang-tidy odpowiadał za źródła MSL oraz C.
Dla yaml i markdown były to odpowiednio markdownlint oraz yamllint.
Upewniono się także by każdy z plików posiadał stosowny nagłówek informujący o przynależności praw autorskich.
\code{Swift}
     {Styl programistyczny na przykładzie struktury animacji}
     {code/animation/PNKeyframeAnimation.swift}
\subsubsection{Nazewnictwo}
Biblioteki w ekosystemie Apple używają ustalonych przedrostków do zdefiniowania wprowadzanych typów.
Historycznie wynikało to z ograniczeń Objective-C, gdzie istniała jedyna, globalna przestrzeń nazw.
Wsparcie wsteczne sprawiło, że konwencja utrzymała się.
Z tego względu w projekcie zdecydowano się ją podtrzymać i wybrano przedrostek \textit{PN} do własnego użytku.
Dokonano jednak rozróżnienia ze względu na przeznaczenie danego typu.
W przypadku protokołów i struktur, które nie posiadają zachowania użyta jest podstawowa forma przedrostka.
Klasy bądź struktury mające je lub implementujące interfejsy używają przedrostka \textit{PNI}.
Typy współdzielone pomiędzy przestrzeń adresową GPU oraz CPU definiowane są jako \textit{PNGPU}.
\subsubsection{Aliasy}
Powszechne jest, że jeden typ danych wykorzystywany jest w różnych kontekstach.
Przykładowo, liczba zmiennoprzecinkowa może posłużyć do określenia miary kąta, jak i odległości pomiędzy obiektami.
Znajomość zastosowania nie zawsze pomaga w trafnym specyfikowaniu zakresu.
Oczekując kąta jako parametru funkcji nie jest wiadome czy chodzi o formę stopni czy radianów.
Z tego powodu wprowadzono szereg aliasów mających pomóc użytkownikom uniknąć niejednoznaczności.
Określając właściwości kamery zamiast oczekiwać miary pola widzenia w liczbie zmiennoprzecinkowej oczekuje się podania liczby typu \textit{PNRadians}.

