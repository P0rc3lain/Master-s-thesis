%
%  Copyright © 2022 Mateusz Stompór. All rights reserved.
%

\section{Jakość}
Systematyczny rozwój kolejnych modułów biblioteki bezpośrednio wpływał na zwiększanie się jej objętości.
Dążąc do zapewnienia rozwiązania możliwie wolnego od błędów cyklicznie wykonywano manualną weryfikacje funkcjonalności.
Wymagania czasowe tego procesu starano się zminimalizować za pomocą narzędzi dostępnych na rynku.
Nie była to jednak jedyna płaszczyzna w jakiej postrzegano jakość.
Skierowanie w stronę kodu otwartego źródłowo wymaga by kryterium objęło także sferę czytelności.
\par
Pierwszym krokiem w tym kierunku była decyzja o użyciu analizatorów kodu.
Ich działanie opiera się o statyczne podejście.
Wnioski wyciągane są na podstawie zawartości plików, a nie efektów które potencjalnie daje wywołanie funkcji.
\par
W przypadku języka Swift wykorzystano \textit{SwiftLint}.
Umożliwia wychwycenie błędy kompilacji na wczesnym etapie.
Wyraźnie pomaga również w momentach gdy następuje dereferencja wartości opcjonalnej.
Wówczas linter weryfikuje czy nie dokonano tego w sposób, który mógłby objawić się błędem krytycznym.
Większość implementowanych reguł odnosi się jednak do stylu programistycznego.
Wypracowane zostały one w oparciu o przemyślenia płynące od twórców Swift.
Uwzględnienie sugestii nie tylko sprawia, że kod staje się spójny wewnętrznie, ale także z innymi publicznymi repozytoriami aplikującymi podejście.
\par
Drugim analizatorem, który zdecydowano się zastosować był \textit{markdownlint}.
Obszar, który pokrył obejmował dokumentację.
Pozwolił zadbać o poprawne formatowanie i wykluczenie błędów syntaktycznych.
\par
Analiza objęła również pliki typu \textit{yaml}.
W tym celu posłużono się narzędziem \textit{yamllint}.
Jego zastosowanie ograniczało się do weryfikacji definicji skryptów automatyzujących dla platformy GitHub.
Sprawdzono nim również same konfiguracje linterów, które zachowane zostały w głównym katalogu repozytorium.
Podobnie jak w poprzednich przypadkach zabieg pozwolił narzucić spójny styl i ustrzec się przed błędami składniowymi.
\par
Dążąc do zapewnienia poprawności działania algorytmów wykonywano testy automatyczne.
Oparto je o natywną bibliotekę \textit{XCTest} i zaprogramowane zostały, podobnie jak sam silnik graficzny, w języku Swift.
Starano się możliwie maksymalizować ich użycie, jednak ze względu na nakład czasowy jaki narzuca ich rozwój ograniczono się do newralgicznych aspektów silnika.
Postrzegano za nie miejsca w których zachodzi użycie aparatu matematycznego lub złożoność samego algorytmu jest wysoka.
Oznacza to, że w głównej mierze wykorzystane zostały one przy weryfikacji mechanizmów obecnych przy grafie sceny, animacjach czy przecięciach pomiędzy obiektami na scenie.
Ostatnim przypadkiem użycia były struktury danych używane w wielu miejscach aplikacji, jak pomocnicze metody do operacji wektorowych czy macierzowych.
Sumarycznie pokrycie testami kodu Swift oscylowało na poziomie 30\%.
\par
Nie należy zapominać, że około 10\% z całego stworzonego kodu dotyczył programów cieniujących.
Wyłączono je całkowicie poza obszar objęty testami automatycznymi.
Wynikało to z niemożności przeprowadzenia takiej operacji.
Na rynku istnieje niewielka ilość produktów skierowanych na obsługę zagadnienia.
Największą popularnością cieszy się technologia przedstawiona przez Google \longpause \textit{Amber}~\cite{google_amber} \longpause jednak nie wspiera ona platformy Apple.
W momencie tworzenia pracy Metal nie posiadał ani jednej biblioteki, która mogłaby posłużyć do weryfikacji.
Dotyczy to zarówno poziomu testów pojedynczych funkcji, jak i całych programów cieniujących.
Rozważano rozwój własnego rozwiązania w ramach pracy, jednak nakład czasowy wymagany do spełnienia warunku używalności sprawił, że zrezygnowano z tego pomysłu.
% Powinienem jaśniej powiedzieć, że tutaj po prostu nie ma na razie frameworka
% Potencjalnie mógłbym nakreślić jak powinien działać