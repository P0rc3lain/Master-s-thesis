%
%  Copyright © 2022 Mateusz Stompór. All rights reserved.
%

\section{Potok renderowania}
Moc obliczeniowa karty graficznej wykorzystywana może być w dwojaki sposób.
Pierwszy, coraz częściej spotykany polega na użyciu procesora grafiki w celu przeprowadzenia dowolnych rachunków o charakterze współbieżnym.
Służy to odciążeniu zasobów procesora CPU przy jednoczesnym zwiększeniu wydajności ze względu na oddelegowanie pracy do jednostki będącej lepiej przystosowaną do tego typu zadania.
Idea określana jest mianem GPGPU \eng{General-Purpose GPU}, a więc służy wykonaniu pracy nienastawionej bezpośrednio na tworzenie obrazu.
Drugi, tradycyjny typ użycia to skorzystanie ze wbudowanego potoku renderowania.
Choć interfejsy API charakteryzują się subtelnymi różnicami, to kroki obecne podczas procesu pozostają niezmienne.
\par
Potok renderowania przedstawiony i omówiony zostanie na podstawie ilustracji dotyczącej specyfikacji technologii Metal.
Etapy będące jego częścią następują bezpośrednio po sobie i mają charakter sekwencyjny.
Część z nich nie podlega żadnej konfiguracji, inne mogą być parametryzowane w ograniczony sposób.
Te kluczowe są w pełni modyfikowalne, a logika ich działania dostarczana jest w formie programu komputerowego. 
\figh{images/metal-rendering-pipeline.png}
     {Potok renderowania wykorzystywany w języku Metal, Apple Inc.}
     {fig:metal-rendering-pipeline}
     {\linewidth}
\paragraph*{Figury \eng{Primitives}}
Pierwszy krok stanowi wejście do potoku renderowania.
Dane pobierane są z określonego przez użytkownika bufora danych i przetwarzane jako punkty, w przestrzeni dwu, trzy lub czterowymiarowej.
Dalszemu procesowaniu podlegać mogą w niezmienionej formie, być interpretowane jako linie, trójkąty lub łączone w kilka innych figur.
Określenie w jaki sposób mają być ze sobą spajane, o ile taka potrzeba zachodzi, ma kluczowy wpływ na ich dalszy wygląd po procesie rasteryzacji.
\paragraph*{Cieniowanie wierzchołkowe \eng{Vertex Function}}
Cieniowanie wierzchołków jest pierwszym w pełni konfigurowalnym etapem potoku.
Użytkownik dostarcza kod źródłowy realizujący zadanie w postaci pliku \textit{.metal}, który kompilowany jest do instrukcji maszynowych procesora GPU.
Rdzenie uruchamiają program niezależnie dla wierzchołków znajdujących się w buforze danych do momentu przeprocesowania każdego z nich.
Oczekiwanym wynikiem będącym bezpośrednim efektem działania algorytmu jest określenie ostatecznej pozycji wierzchołka w odniesieniu do obiektywu kamery.
Przez wzgląd na fakt, że aranżacja sceny i jej wymiary są cechami indywidualnymi dla poszczególnych aplikacji zachodzi potrzeba wykorzystania generycznego mechanizmu, który pozwoli określić jak pozycja wierzchołka koresponduje do powierzchni na której jest wyrysowywana.
Zadanie to realizowane jest za pomocą użycia znormalizowanego układu współrzędnych urządzenia.
W tym celu pozycja wierzchołka w układzie współrzędnych kamery rzutowana jest na wspominany układ urządzenia.
Jeśli pozycja wierzchołka znajduje się wewnątrz graniastosłupa ograniczającego ten układ wierzchołek kontynuuje drogę przez potok, w przeciwnym razie jest odrzucany.
\paragraph*{Rasteryzacja \eng{Rasterization}}
Zadaniem rasteryzacji jest rozwiązanie problemu widzialności~\cite{rasterization_implementation}.
Aktualnie przetwarzane koordynaty wierzchołków rzutowane są na dyskretny układ współrzędnych obrazu wyjściowego.
W zależności od wybranego typu figury geometrycznej, która ma zostać stworzona na podstawie wierzchołków algorytm przybiera nieco inną formę.
W przypadku trójkątów jeżeli pole figury ma kontakt z pikselem obrazu wyjściowego wówczas jest on włączany do dalszego procesowania, w przeciwnym razie algorytm kończy działanie.
\figh{images/pipeline/rasterization.png}
     {Przedstawienie idei procesu rasteryzacji}
     {fig:pipeline-rasterization}
     {4cm}
\paragraph*{Cieniowanie Fragmentów \eng{Fragment Function}}
Piksele, które służą do opisu figury po procesie rasteryzacji określane są mianem fragmentów.
Każdy uprzednio nieodrzucony poddany może być dalszej modyfikacji.
Stanowi to kolejny, w pełni konfigurowalny etap potoku.
Podobnie jak w przypadku cieniowania wierzchołków użytkownik jest zobowiązany do zapewnienia funkcji stworzonej w oparciu o MSL \eng{Metal Shading Language}.
W tradycyjnym podejściu odpowiada ona za określenie wpływu światła na geometrię.
Dzięki temu obserwator jest w stanie dostrzec w jaki sposób oświetlenie usytuowane na scenie oddziałuje na model.
\figh{images/phong-shading.jpeg}
     {Cieniowanie na przykładzie algorytmu Phonga}
     {fig:phong-shading}
     {6cm}
\paragraph*{Przycinanie \eng{Scissor}}
Zdarza się, że generowany obraz powinien być zaprezentowany w częściowej formie.
W takim wypadku programista może określić prostokątny obszar, który powinien zostać utrwalony.
Fragmenty usytuowane poza nim nie będą zapisywane na wyjściu.
\figh{images/pipeline/scissoring.png}
     {Przycinanie na przykładzie obrazu trójkąta}
     {fig:scissoring}
     {6cm}
\paragraph*{Wielopróbkowanie \eng{Multisample}}
Następnym, opcjonalnym krokiem w potoku renderowania jest wielopróbkowanie.
Celem, którym ma być zrealizowany jest wygładzenie krawędzi pomiędzy różnymi obiektami na obrazie wyjściowym.
Efekt osiągany jest za pomocą zmiany sposobu działania algorytmu rasteryzacji.
Zamiast opierać się na pojedynczym punkcie do określenia czy figura pokrywa dany fragment używana jest ich większa ilość.
Cieniowanie fragmentów wciąż wykonywane jest tylko i wyłącznie dla pojedynczego elementu, jednak kolor wyjściowy który został uzyskany mieszany jest z tłem w oparciu o dane z próbkowania dla większej liczby punktów.
\figh{images/pipeline/multisampling.png}
     {Zobrazowanie idei wielopróbkowania}
     {fig:multisampling}
     {6cm}
\paragraph*{Test szablonu \eng{Stencil Test}}
Poza wspomnianym przycinaniem użytkownik ma dodatkową możliwość, aby ograniczyć powierzchnie obrazu, która zostanie zaprezentowana.
Operacja dokonywana jest z wysoką ziarnistością \longpause dla każdego piksela obrazu.
W tym celu wykorzystywane są maski binarne.
Idea działania algorytmu nie jest złożona.
Jeśli dla zadanego fragmentu wartość w buforze maski wynosi \textit{1} wówczas kontynuuje on drogę przez potok, w przeciwnym wypadku jest odrzucany.
\figh{images/pipeline/binary-mask.png}
     {Przykład maski binarnej opisującej kształtem balon}
     {fig:binary-mask}
     {4cm}
\paragraph*{Test głębi \eng{Depth Test}}
W dalszej kolejności wykonywany jest test widoczności.
Jego celem jest sprawdzenie, czy dany fragment nie został przesłonięty przez inny.
Zachodzi potrzeba, aby karta graficzna skorzystała z dodatkowego bufora.
Wartości w nim przechowywane odpowiadają odległości poszczególnych fragmentów od obiektywu kamery.
Im dalej się on znajduje \longpause tym liczba jest większa.
W najczęstszym przypadku zadanie testu polega na wykonaniu pojedynczej operacji porównania \longpause wartości zapisanej w buforze z aktualną, obliczoną dla obecnie procesowanego fragmentu.
\paragraph*{Wynik widoczności \eng{Visibility Result}}
Uprzednio wyliczony wynik z działania testu głębi zachowany jest w postaci liczby binarnej.
Widoczny fragment powiązywany jest z wartością \textit{prawda}, \textit{fałsz} przypisywany jest w przeciwnym przypadku.
\paragraph*{Mieszanie \eng{Blend}}
\figh{images/pipeline/blending.png}
     {Mieszanie kolorów. Zobrazowanie braku przemienności operacji}
     {fig:blending}
     {6cm}
Ostatnim krokiem w procesie renderowania jest mieszanie.
Uruchamiane jest ono zawsze, jednak zauważalne rezultaty przynosi w przypadku gdy kolor zadanego fragmentu charakteryzuje się stopniem przeźroczystości.
W celu wykonania obliczenia rozpatrywany jest wynik widoczności po procesie testowania głębi, kolor nowo wygenerowanego fragmentu oraz ten, który już znajduje się w buforze.
Przez wzgląd na brak przemienności operacji istotnym jest, aby charakteryzujące się przeźroczystością modele wyrysowywane były od znajdującego się najdalej kamery do najbliższego.
\paragraph*{Bufor wyjścia \eng{Attachment}}
W podstawowym przypadku na bufor wyjścia składają się bufory koloru, głębi oraz szablonu. 
Nie jest jednak to jedyna dozwolona kombinacja.
Bufory głębi oraz szablonu są opcjonalne i o ile aktywne są unikalne.
Załączników koloru natomiast może występować większa ilość.
\newline
\par
Opisany powyżej przepływ wierzchołków modelu przez poszczególne etapy generowania klatki utożsamiany powinien być z pojęciem \textit{single-pass rendering}. 
Termin oznacza, że stworzenie obrazu z modelem reprezentowanym w finalnej formie potrzebuje uruchomienia potoku dokładnie jeden raz.
Podejście nadal wykorzystywane jest powszechnie w przypadku nanoszenia siatek opisanych przy pomocy materiałów charakteryzujących się przeźroczystością.
Innym przykładem może być chęć zapewnienia obiektowi unikalnych w stosunku do reszty sceny, odmiennych od przyjętego standardowego modelu oświetlenia walorów wizualnych.
\par
Rozważając jednak przypadek, gdzie większość obiektów korzysta ze wspólnego oświetlenia, stwierdzić należy, że tego rodzaju podejście ma ograniczone zastosowanie.
Wynika z faktu wynalezienia bardziej efektywnych technik renderowania \longpause poprzez zwiększenie ilości wywołania potoku z mniej wymagającymi obliczeniami, co charakteryzuje się wyższą wydajnością.
Ponadto, chęć polepszenia walorów wizualnych wymaga użycia tymczasowych, pośrednich klatek.
W efekcie okazuje się, że stworzenie pojedynczego wycinka animacji wiązać się może z dziesiątkami wywołań potoku.
Niemniej jednak przywołanie podstawowej formy algorytmu pozwala wyjaśnić jaka koncepcja stoi za utylizacją GPU.
